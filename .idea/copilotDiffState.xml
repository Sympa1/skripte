<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Python/git_push.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Python/git_push.py" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;# -*- coding: utf-8 -*-&#10;&#10;&quot;&quot;&quot;&#10;Push-Script (git_push.py)&#10;Führt einen Git Add, Commit und Push im konfigurierten Repository aus.&#10;&#10;Dieses Skript prüft auf Änderungen im Repository, staged alle Dateien,&#10;erstellt einen Commit mit Zeitstempel und pusht die Änderungen zum Remote-Repository.&#10;&quot;&quot;&quot;&#10;&#10;import os&#10;import sys&#10;import subprocess&#10;from pathlib import Path&#10;from datetime import datetime&#10;&#10;&#10;def load_env_file(env_path):&#10;    &quot;&quot;&quot;&#10;    Lädt die .env-Datei und extrahiert den REPO_PFAD_LIN.&#10;    &#10;    Args:&#10;        env_path: Pfad zur .env-Datei&#10;        &#10;    Returns:&#10;        str: Der Repository-Pfad aus der .env-Datei oder None&#10;    &quot;&quot;&quot;&#10;    # Prüfe, ob die .env-Datei existiert&#10;    if not os.path.exists(env_path):&#10;        print(f&quot;\033[33mWARNUNG: .env-Datei nicht gefunden unter: {env_path}\033[0m&quot;)&#10;        return None&#10;&#10;    try:&#10;        # Öffne und lese die .env-Datei&#10;        with open(env_path, 'r', encoding='utf-8') as f:&#10;            # Durchlaufe alle Zeilen&#10;            for line in f:&#10;                line = line.strip()&#10;                &#10;                # Suche nach der REPO_PFAD_LIN Variable&#10;                if line.startswith('REPO_PFAD_LIN'):&#10;                    # Extrahiere den Wert nach dem = Zeichen&#10;                    parts = line.split('=', 1)&#10;                    if len(parts) == 2:&#10;                        # Entferne Anführungszeichen und Leerzeichen&#10;                        value = parts[1].strip().strip('&quot;').strip(&quot;'&quot;)&#10;                        print(f&quot;RepoPfad aus .env-Datei: {value}&quot;)&#10;                        return value&#10;&#10;        # Variable nicht gefunden&#10;        return None&#10;        &#10;    except Exception as e:&#10;        # Fehlerbehandlung beim Lesen der Datei&#10;        print(f&quot;\033[0;31mFehler beim Lesen der .env-Datei: {e}\033[0m&quot;)&#10;        return None&#10;&#10;&#10;def run_git_command(command, capture_output=True):&#10;    &quot;&quot;&quot;&#10;    Führt einen Git-Befehl aus und gibt das Ergebnis zurück.&#10;    &#10;    Args:&#10;        command: Liste mit dem Git-Befehl und seinen Argumenten&#10;        capture_output: Ob die Ausgabe abgefangen werden soll&#10;        &#10;    Returns:&#10;        subprocess.CompletedProcess: Das Ergebnis des Befehls&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Führe den Git-Befehl aus&#10;        result = subprocess.run(&#10;            command,&#10;            capture_output=capture_output,&#10;            text=True,&#10;            check=False  # check=False verhindert Exception bei Fehler&#10;        )&#10;        return result&#10;        &#10;    except FileNotFoundError:&#10;        # Git ist nicht installiert oder nicht im PATH&#10;        print(&quot;\033[0;31mGit ist nicht installiert oder nicht im PATH!\033[0m&quot;)&#10;        sys.exit(1)&#10;    except Exception as e:&#10;        # Allgemeine Fehlerbehandlung&#10;        print(f&quot;\033[0;31mFehler beim Ausführen von Git-Befehl: {e}\033[0m&quot;)&#10;        sys.exit(1)&#10;&#10;&#10;def git_push(repo_path):&#10;    &quot;&quot;&quot;&#10;    Führt Git Add, Commit und Push im angegebenen Repository aus.&#10;    &#10;    Diese Funktion:&#10;    1. Prüft den Git-Status auf Änderungen&#10;    2. Staged alle Änderungen mit 'git add .'&#10;    3. Erstellt einen Commit mit Zeitstempel&#10;    4. Pusht die Änderungen zum Remote-Repository&#10;    &#10;    Args:&#10;        repo_path: Pfad zum Git-Repository&#10;    &quot;&quot;&quot;&#10;    # Validiere, dass das Verzeichnis existiert&#10;    if not os.path.isdir(repo_path):&#10;        print(f&quot;\033[0;31mVerzeichnis {repo_path} existiert nicht!\033[0m&quot;)&#10;        sys.exit(1)&#10;&#10;    print(f&quot;Wechsel zu Repository-Verzeichnis: {repo_path}&quot;)&#10;&#10;    # Wechsle in das Repository-Verzeichnis&#10;    try:&#10;        os.chdir(repo_path)&#10;    except Exception as e:&#10;        print(f&quot;\033[0;31mFehler beim Wechsel in das Verzeichnis {repo_path}!\033[0m&quot;)&#10;        print(f&quot;Fehler: {e}&quot;)&#10;        sys.exit(1)&#10;&#10;    # Status überprüfen mit --porcelain für maschinenlesbare Ausgabe&#10;    # --porcelain gibt eine konsistente, parsbare Ausgabe zurück&#10;    result = run_git_command(['git', 'status', '--porcelain'])&#10;    status = result.stdout.strip()&#10;    print(f&quot;Git Status: {status}&quot;)&#10;&#10;    # Prüfe, ob Änderungen vorhanden sind&#10;    if status:&#10;        # Es gibt Änderungen im Repository&#10;        print(&quot;\033[33mAenderungen festgestellt. Bereite Commit und Push vor...\033[0m&quot;)&#10;&#10;        # Stage alle Änderungen (neue, geänderte und gelöschte Dateien)&#10;        run_git_command(['git', 'add', '.'])&#10;        print(&quot;Änderungen wurden gestaged.&quot;)&#10;&#10;        # Erstelle einen Zeitstempel für die Commit-Nachricht&#10;        # Format: YYYY-MM-DD HH:MM:SS&#10;        zeitstempel = datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)&#10;        commit_message = f&quot;Automatischer Commit am: {zeitstempel}&quot;&#10;&#10;        # Erstelle den Commit mit der Zeitstempel-Nachricht&#10;        run_git_command(['git', 'commit', '-m', commit_message])&#10;        print(f&quot;Commit wurde erstellt mit Nachricht: {zeitstempel}&quot;)&#10;&#10;        # Push zum Remote-Repository durchführen&#10;        print(&quot;\033[32mPushen der Aenderungen...\033[0m&quot;)&#10;        result = run_git_command(['git', 'push'], capture_output=True)&#10;&#10;        # Prüfe, ob der Push erfolgreich war&#10;        if result.returncode == 0:&#10;            print(&quot;\033[32mPush erfolgreich!\033[0m&quot;)&#10;        else:&#10;            # Push ist fehlgeschlagen, zeige Fehlermeldung&#10;            print(&quot;\033[0;31mPush fehlgeschlagen!\033[0m&quot;)&#10;            print(result.stderr)&#10;            sys.exit(1)&#10;    else:&#10;        # Keine Änderungen vorhanden&#10;        print(&quot;\033[34mKeine Aenderungen gefunden.\033[0m&quot;)&#10;&#10;&#10;def main():&#10;    &quot;&quot;&quot;&#10;    Hauptfunktion des Skripts.&#10;    &#10;    Lädt die Konfiguration aus der .env-Datei und führt den Git Push-Workflow aus.&#10;    &quot;&quot;&quot;&#10;    # Ermittle das Verzeichnis, in dem sich dieses Skript befindet&#10;    script_dir = Path(__file__).parent.resolve()&#10;    &#10;    # Die .env-Datei liegt eine Ebene über dem Skript-Verzeichnis&#10;    env_path = script_dir.parent / '.env'&#10;&#10;    # Lade den Repo-Pfad aus der .env-Datei&#10;    repo_path = load_env_file(env_path)&#10;&#10;    # Fallback auf aktuelles Verzeichnis, falls kein Pfad gefunden wurde&#10;    if repo_path is None:&#10;        repo_path = '.'&#10;&#10;    # Führe den Git Push-Workflow aus&#10;    git_push(repo_path)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>